require 'set'

class RelevantVulnerability # Non ActiveRecord

  @@many_systems = 20

  def self.many_systems()
    return @@many_systems
  end
  
  def self.set_many_systems(n)
    @@many_systems = n
  end
 
  def self.is_a_huge_project?(project)
    return project.systems.count >= many_systems
  end
  
  def self.has_too_many_systems?(user)
    return users_systems(user).count >= many_systems
  end

  def self.extract_systems_from_project(project)
    if project.nil? or project.systems.empty?
      return []
    end

    systems = Set.new
    systems.merge(project.systems)
    res = systems.to_a
    if res.count > many_systems
      return res[0..many_systems]
    end
    return res
  end

  def self.users_systems(user)
    return [] if (user.nil? or user.projects.empty?)

    all_projects = user.projects

    systems = Set.new
    
    all_projects.each do |project|
      systems.merge(extract_systems_from_project(project))
    end
    
    res = systems.to_a
    if res.count > many_systems
      return res[0..many_systems] 
    end
    return res
  end

  def self.prepare_system_name(system)
    return nil if system.nil? or system.empty?
    system = system.downcase.gsub(/\s+$/, '').gsub(/^\s+/, '')
    return nil if system.empty?
    return system    
  end

  def self.vulnerability_affects_system?(vulnerability, system)
    system = prepare_system_name(system)
    return false if system.nil?
    return false if vulnerability.nil? or not vulnerability.valid?
    if vulnerability.tags.empty?
      return vulnerability_affects_system_by_summary?(vulnerability, system)
    else
      return vulnerability.tags.where('LOWER(component) = ?', system).any?
    end
  end

  def self.vulnerability_affects_system_by_summary?(vulnerability, system)
    system = prepare_system_name(system)
    return false if system.nil?

    return false if vulnerability.nil? or vulnerability.summary.nil? or vulnerability.summary.empty?

    s = system
    system_regex = /^#{s}$|^#{s}\W|\W#{s}\W|\W#{s}$/

    if vulnerability.summary.downcase =~ system_regex
      return true
    end
    return false
  end

  def self.all_relevant_vulnerabilities_for_user(user)
    return filter_relevant_vulnerabilities_for_user(Vulnerability.join_tags_and_reactions(user), user)
  end

  def self.filter_relevant_vulnerabilities_for_user(vulnerabilities, user)
    return filter_relevant_vulnerabilities(vulnerabilities, users_systems(user))
  end

  def self.filter_relevant_vulnerabilities_for_project(vulnerabilities, project)
    return filter_relevant_vulnerabilities(vulnerabilities, extract_systems_from_project(project))
  end

  def self.tag_match(vulnerabilities, systems)
    conditions =['']
    systems.each do |system|
      system = prepare_system_name(system)
      next if system.nil?
      newpart = 'LOWER(tags.component) = ?'
      conditions[0] =  conditions[0].empty? ? newpart : conditions[0] + ' OR ' + newpart
      conditions.push "#{system}"
    end
    tag_conditions = conditions   
    
    return vulnerabilities.where(tag_conditions)
  end
  
  def self.summary_match(vulnerabilities, systems)
    conditions =['']
  
    systems.each do |system|
      system = prepare_system_name(system)
      next if system.nil?
      newpart = 'LOWER(summary) LIKE ?'
      conditions[0] =  conditions[0].empty? ? newpart : conditions[0] + ' OR ' + newpart
      conditions.push "%#{system}%"
    end    
  
    summary_conditions = conditions
   
    return vulnerabilities.where(summary_conditions)
  end
 
  def self.filter_by_regex_in_summary(vulnerabilities, systems)
    vulns = []
    vulnerabilities.find_each do |v|
      vulns.push(v) if systems.any? { |sys| vulnerability_affects_system_by_summary?(v, sys) }
    end
    return vulns
  end
  

  def self.filter_relevant_vulnerabilities(vulnerabilities, systems)

    return Vulnerability.none if systems.nil? or systems.empty?
    
    tag_match = tag_match(vulnerabilities, systems)
    
    summary_match = summary_match(vulnerabilities.where('tags.id IS NULL'), systems)

    summary_match = filter_by_regex_in_summary(summary_match, systems)

    return tag_match + summary_match
  end

  def self.affected_systems(vulnerability, user)
    systems = RelevantVulnerability.users_systems(user)
    res = []
    systems.each do |system|
      res.push system if vulnerability_affects_system?(vulnerability, system)
    end
    res
  end

  def self.affects_user?(vulnerability, user)
    systems = RelevantVulnerability.users_systems(user)
    return systems.any?( &->(sys){vulnerability_affects_system?(vulnerability, sys)} )
  end

  def self.projects_having_system(system, user)
    res = []
    system = prepare_system_name(system)
    return [] if system.nil? or user.nil? or user.projects.empty?

    user.projects.each do |project|
      res.push project if ( not project.nil?  and 
           project.systems.map(&->(sys){prepare_system_name(sys)}).include? system )
    end
    res
  end

  def self.explanator(vulnerabilities, user)
    vv = Vulnerability.where(id: vulnerabilities.to_a.map(&:id)).includes(:tags)
    all_projects = user.projects.to_a
    proj_dict = {}
    
    all_projects.each do |proj|
      systs = proj.systems.to_a[0..many_systems]
      systs.each do |s|
        proj_dict[s] ||= []
        proj_dict[s] += [proj]
      end
    end

    explanations = {}
    
    vv.each do |v|
      explanations[v] ||= []
      proj_dict.each do |sys, projs|
        if v.tags.map(&:component).map(&->(c){prepare_system_name(c)}).include?(prepare_system_name(sys))
          explanations[v] +=  [[sys, projs]]
        elsif vulnerability_affects_system_by_summary?(v, sys)
          explanations[v] +=  [[sys, projs]]
        end
      end  
    end

    return explanations
  end

end

