require 'set'

class RelevantVulnerability # Non ActiveRecord

  @@many_systems = 20

  def self.many_systems()
    return @@many_systems
  end
  
  def self.set_many_systems(n)
    @@many_systems = n
  end
 
  def self.is_a_huge_project?(project)
    return project.systems.count >= many_systems
  end
  
  def self.has_too_many_systems?(user)
    return users_systems(user).count >= many_systems
  end

  def self.extract_systems_from_project(project)
    if project.nil? or project.systems.empty?
      return []
    end

    systems = Set.new
    systems.merge(project.systems)
    res = systems.to_a
    if res.count > many_systems
      return res[0..many_systems]
    end
    return res
  end

  def self.users_systems(user)
    return [] if (user.nil? or user.projects.empty?)

    all_projects = user.projects

    systems = Set.new
    
    all_projects.each do |project|
      systems.merge(extract_systems_from_project(project))
    end
    
    res = systems.to_a
    if res.count > many_systems
      return res[0..many_systems] 
    end
    return res
  end

  def self.vulnerability_affects_system?(vulnerability, system, prefer_tags = true)
    return false if vulnerability.nil? or vulnerability.summary.nil? or vulnerability.summary.empty?
    return false if system.nil? or system.empty?
    s=system.downcase.gsub(/\s/, '')
    if prefer_tags and not vulnerability.tags.empty?
      return vulnerability.tags.map(&->(t){t.component.downcase}).include?(s)
    end
    
    system_regex = /^#{s}$|^#{s}\W|\W#{s}\W|\W#{s}$/

    if vulnerability.summary.downcase =~ system_regex
      return true
    end
    return false
  end

  def self.all_relevant_vulnerabilities_for_user(user)
    return filter_relevant_vulnerabilities_for_user(Vulnerability.join_tags_and_reactions(user), user)
  end

  def self.filter_relevant_vulnerabilities_for_user(vulnerabilities, user)
    return filter_relevant_vulnerabilities(vulnerabilities, users_systems(user))
  end

  def self.filter_relevant_vulnerabilities_for_project(vulnerabilities, project)
    return filter_relevant_vulnerabilities(vulnerabilities, extract_systems_from_project(project))
  end
 
  def self.filter_relevant_vulnerabilities(vulnerabilities, systems)

    return Vulnerability.none if systems.nil? or systems.empty?
    
    conditions =['']
    systems.each do |system|
      newpart = 'LOWER(tags.component) = ?'
      conditions[0] =  conditions[0].empty? ? newpart : conditions[0] + ' OR ' + newpart
      conditions.push "#{system.downcase}"
    end
    tag_conditions = conditions   

    conditions =['']
    systems.each do |system|
      newpart = 'LOWER(summary) LIKE ?'
      conditions[0] =  conditions[0].empty? ? newpart : conditions[0] + ' OR ' + newpart
      conditions.push "%#{system.downcase}%"
    end    
    summary_conditions = conditions

    tag_conds = "(#{tag_conditions[0]})"
    sum_conds = "(#{summary_conditions[0]})"
    conds = " #{tag_conds} OR ( tags.id IS NULL AND (#{sum_conds}))"
    conditions = [conds]
    
    conditions = conditions.concat tag_conditions[1..-1]
    conditions = conditions.concat summary_conditions[1..-1]
    
    first_fetch = vulnerabilities.where(conditions)
    vulns = []
    first_fetch.each do |v|
      vulns.push(v) if systems.any? { |sys| vulnerability_affects_system?(v, sys) }
    end
    vulns
  end

  def self.affected_systems(vulnerability, user)
    systems = RelevantVulnerability.users_systems(user)
    res = []
    systems.each do |system|
      res.push system if vulnerability_affects_system?(vulnerability, system)
    end
    res
  end
  
  def self.affects_user?(vulnerability, user)
    systems = RelevantVulnerability.users_systems(user)
    return systems.any?( &->(sys){vulnerability_affects_system?(vulnerability, sys)} )
  end

  def self.projects_having_system(system, user)
    res = []
    if (system.nil? or system.empty? or user.nil? or user.projects.empty? )
      return []
    end
    user.projects.each do |project|
      res.push project if ( not project.nil?  and 
           project.systems.map(&->(s){s.downcase}).include? system.downcase )
    end
    res
  end


end

