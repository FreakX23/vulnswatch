require 'set'

class RelevantVulnerability # Non ActiveRecord

  @@many_systems = 20

  def self.many_systems()
    return @@many_systems
  end
  
  def self.set_many_systems(n)
    @@many_systems = n
  end
 
  def self.is_a_huge_project?(project)
    return project.systems.count >= many_systems
  end
  
  def self.has_too_many_systems?(user)
    return users_systems(user).count >= many_systems
  end

  def self.extract_systems_from_project(project)
    if project.nil? or project.systems.empty?
      return []
    end

    systems = Set.new
    systems.merge(project.systems)
    res = systems.to_a
    if res.count > many_systems
      return res[0..many_systems]
    end
    return res
  end

  def self.users_systems(user)
    return [] if (user.nil? or user.projects.empty?)

    all_projects = user.projects

    systems = Set.new
    
    all_projects.each do |project|
      systems.merge(extract_systems_from_project(project))
    end
    
    res = systems.to_a
    if res.count > many_systems
      return res[0..many_systems] 
    end
    return res
  end

  def self.vulnerability_affects_system?(vulnerability, system)
    return false if vulnerability.nil? or vulnerability.summary.nil? or vulnerability.summary.empty?
    return false if system.nil? or system.empty?
    s=system.downcase
    system_regex = /^#{s}$|^#{s}\W|\W#{s}\W|\W#{s}$/

    # if the affected system is defined, we use only it
    if not vulnerability.affected_system.nil? and 
       not vulnerability.affected_system.empty?
          return vulnerability.affected_system.downcase =~ system_regex
    end

    # we search summary if a component is not defined
    if vulnerability.summary.downcase =~ system_regex
      return true
    end
    return false
  end

  def self.relevant_vulnerabilities(user)
    return relevant_vulnerabilities_for_systems(users_systems(user))
  end

  def self.relevant_vulnerabilities_for_systems(systems)
    return pick_relevant(Vulnerability.all, systems)
  end

  def self.pick_relevant_for_project(vulnerabilities, project)
    return pick_relevant(vulnerabilities, extract_systems_from_project(project))
  end
 
  def self.pick_relevant(vulnerabilities, systems)

    return Vulnerability.none if systems.nil? or systems.empty?

    conditions =['']
      systems.each do |system|
      newpart = 'LOWER(summary) LIKE ? OR LOWER(affected_system) LIKE ?'
      conditions[0] =  conditions[0].empty? ? newpart : conditions[0] + ' OR ' + newpart
      conditions.push "%#{system.downcase}%"
      conditions.push "%#{system.downcase}%"
    end    
    
    first_fetch = vulnerabilities.where(conditions).order(modified: :desc)
    vulns = []
    first_fetch.each do |v|
      vulns.push(v) if systems.any? { |sys| vulnerability_affects_system?(v, sys) }
    end
    vulns
  end

  def self.affected_systems(vulnerability, user)
    systems = RelevantVulnerability.users_systems(user)
    res = []
    systems.each do |system|
      res.push system if vulnerability_affects_system?(vulnerability, system)
    end
    res
  end

  def self.projects_having_system(system, user)
    res = []
    if (system.nil? or system.empty? or user.nil? or user.projects.empty? )
      return []
    end
    user.projects.each do |project|
      res.push project if ( not project.nil?  and 
           project.systems.map(&->(s){s.downcase}).include? system.downcase )
    end
    res
  end


end

