class Vulnerability < ApplicationRecord
  has_many :reactions, dependent: :destroy
  validates :name, uniqueness: true
  validates :name, presence: true
  validates :summary, presence: true

  # NVD Story
  require 'open-uri'
  require 'zip'
  require 'nokogiri'
  require 'date'


 
  def self.load_vulnerabilities_from_nvd_for_year(year)
    update_from_nvd_zip(get_nvd_url_for_year(year))
  end
  
  def self.load_new_vulnerabilities_from_nvd()
    NvdUpdate.register()
    update_from_nvd_zip(get_nvd_update_url())
  end
  
  protected 

  # NVD URLs

  def self.get_nvd_url_for_year(year)
    "https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-#{year}.xml.zip"
  end

  def self.get_nvd_update_url()
    "https://static.nvd.nist.gov/feeds/xml/cve/2.0/nvdcve-2.0-modified.xml.zip"
  end

  def self.update_from_nvd_zip(httpsaddress)
    content = load_zip_content(httpsaddress)
    cves = parse_xml(content)
    cves.each do |cve|
      add_to_database(cve)
    end
  end

  def self.add_to_database(cve)
    vuln = Vulnerability.find_by name: cve[:cve_id]
    if vuln.nil?
      create_new_vulnerability(cve)
    else
      update_existing_vulnerability(vuln, cve)
    end
  end

  def self.cve_to_attrs(cve)
    { :name => cve[:cve_id], :summary => cve[:summary], :created => cve[:published], :modified => cve[:modified] }
  end  

  def self.create_new_vulnerability(cve)
    Vulnerability.create(cve_to_attrs(cve))
  end

  def self.update_existing_vulnerability(vuln, cve)
    #if vuln.modified != cve[:modified]
      vuln.update_attributes(cve_to_attrs(cve))
    #end
  end

  # XML with CVE descriptions
  def self.parse_xml(content)
    res = []
    return res unless content.length > 0
    Nokogiri::XML::Reader(content).each do |node|
      if node.name == 'entry' && node.node_type == Nokogiri::XML::Reader::TYPE_ELEMENT
        begin
          res.push parse_node(node.outer_xml)
        rescue => exception
          logger.warn "Failed to parse a node due to exception " + exception 
        end
      end
    end
    res
  end
  
  # Parse single CVE entry in the XML file
  def self.parse_node(node)
    doc = Nokogiri::XML(node)
    doc.remove_namespaces!
    summary = doc.at_xpath("//summary").content
    
    rejected = ! (summary =~ /\*\* REJECT \*\*/).nil?
    
    cve_id = doc.at_xpath("//cve-id").content
    
    modified = doc.at_xpath("//last-modified-datetime").content
    modified = DateTime.parse(modified)
    modified = modified.new_offset(Rational(0, 24))
    
    published = doc.at_xpath("//published-datetime").content
    published = DateTime.parse(published)
    published = modified.new_offset(Rational(0, 24))
    
    references = []
    doc.xpath("//references").each do |ref|
      # some values we ignore for now, commented out
      #type = ref.xpath("./@reference_type")
      #source = ref.at_xpath("./source").content
      #reference = ref.at_xpath("reference").content
      link = ref.xpath("./reference/@href")
      references.push(link.to_s)
    end
    
    cpe = doc.xpath("//product").inner_text.to_s

    cvss = ""
    csnode = doc.at_xpath("//cvss")
    if csnode
      cvss += csnode.at_xpath("//score").content + ";"
      cvss += csnode.at_xpath("//access-vector").content + ";"
      cvss += csnode.at_xpath("//access-complexity").content + ";"
      cvss += csnode.at_xpath("//authentication").content + ";"
      cvss += csnode.at_xpath("//confidentiality-impact").content + ";"
      cvss += csnode.at_xpath("//integrity-impact").content + ";"
      cvss += csnode.at_xpath("//availability-impact").content + ";"
      cvss += csnode.at_xpath("//source").content + ";"
      cvss += csnode.at_xpath("//generated-on-datetime").content + ";"
    end
    
    atr = {
      :summary => summary,
      :rejected => rejected,
      :cve_id => cve_id,
      :published => published,
      :modified => modified,
      :references => references,
      :cpe => cpe,
      :cvss => cvss }
    
  end

  def self.load_zip_content(httpsaddress)
    begin
      zip_file = Zip::File.open(open(httpsaddress))
      content = zip_file.first.get_input_stream.read
      return content
    rescue => exception
      logger.warn "Exception when loading CVEs from #{httpsaddress}: " + "#{exception.class.to_s + " " + exception.to_s}"
      return ""
    end
  end


end
